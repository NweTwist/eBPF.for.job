# Путеводитель по полям sk_buff (eBPF)

Ниже — простое и официальное объяснение полей `sk_buff`, разбитое по темам. Это поможет постепенно освоиться: от длины и границ до меток времени, оффлоадов и связи с сокетом.

## Длина и границы данных

- `len`: текущая логическая длина полезных данных в буфере. Сколько байт данных пакет несёт «сейчас», после обработки стека.
- `wire_len`: исходная физическая длина кадра «на проводе», как пришёл с NIC, до внутренней обработки. Полезно для учёта реальной нагрузки канала.
- `data`: указатель на начало доступной области данных в буфере. С него eBPF может безопасно читать.
- `data_end`: указатель на конец доступной области данных. За эту границу выходить нельзя; eBPF обязан проверять, что чтение не выходит за `data_end`.
- `data_meta`: дополнительная область метаданных, которую может использовать BPF (как «карман» для своих заметок). Доступ также с проверками границ.

Коротко: `len` — сколько данных внутри; `wire_len` — сколько было «на проводе»; `data`/`data_end` — безопасные границы чтения; `data_meta` — зона метаданных рядом с данными.

## Типы и протоколы

- `pkt_type`: тип кадра на канальном уровне: кадр для хоста (HOST), широковещательный (BROADCAST), мультикаст (MULTICAST), «не для нас» (OTHERHOST) и т. п. Помогает отличать свои кадры от общих.
- `protocol`: протокол уровня L3 внутри кадра (например, `ETH_P_IP` для IPv4, `ETH_P_IPV6` для IPv6, `ETH_P_ARP` для ARP). Указывает, как разбирать пакет.
- `family`: семейство адресов (обычно `AF_INET` для IPv4 или `AF_INET6` для IPv6). Это «взгляд» со стороны сокета/стека и часто соответствует `protocol`.
- `vlan_present`: флажок наличия VLAN‑метки (0 — нет, 1 — есть).
- `vlan_tci`: содержимое VLAN‑тега (TCI): номер VLAN (VID), приоритет (PCP), индикатор перегрузки (DEI).
- `vlan_proto`: тип VLAN (`ETH_P_8021Q` — стандартный 802.1Q, `ETH_P_8021AD` — Q‑in‑Q).

Зачем: по `pkt_type` понимаем, для кого кадр; по `protocol`/`family` — как его разбирать; по `vlan_*` — в каком VLAN и с каким приоритетом идти.

## Классификация и QoS

- `mark`: policy‑метка (fwmark). Ядро, маршрутизация и фильтры смотрят на неё, чтобы выбрать маршрут/правило. Ставят приложения, iptables/nftables или BPF.
- `priority`: приоритет пакета — подсказка для очередей/планировщиков, чтобы важные пакеты обслуживались раньше.
- `tc_index`: внутренний индекс, который подсистема TC использует при классификации (рабочий ярлык для фильтров/действий).
- `tc_classid`: идентификатор класса TC (major:minor). Определяет, в какой класс QoS попадёт пакет для шейпинга/очередей.
- `queue_mapping`: номер аппаратной очереди NIC для передачи/приёма. Распределяет нагрузку по очередям/ядрам.

Идея: метки и классы описывают важность и правила; очереди — по какой «ленте» пакет пойдёт через NIC.

## Интерфейсы

- `ingress_ifindex`: индекс интерфейса, через который пакет был принят («откуда пришёл»).
- `ifindex`: текущий интерфейс в обработке («где находится сейчас»). Может меняться при редиректе/бридже/виртуальных устройствах.

Сравнивают с известными индексами, чтобы применять порт‑специфичные правила.

## Адреса и порты

- `remote_ip4` / `local_ip4`: IPv4‑адреса удалённой и локальной стороны (32‑бит). Определяют направление и позволяют адресно применять правила.
- `remote_ip6[4]` / `local_ip6[4]`: IPv6‑адреса как четыре 32‑битных слова (суммарно 128 бит). Тот же смысл, что для IPv4.
- `remote_port` / `local_port`: L4‑порты (TCP/UDP) в сетевом порядке байт (big‑endian). Для сравнения учитывают порядок байт.

Обычно смотрят `family`, затем берут соответствующие поля адресов и портов, чтобы идентифицировать поток и применить правила (разрешить/запретить/считать статистику).

## Метки времени и приём

- `tstamp`: программная метка времени ядра — когда пакет прошёл точку обработки. Полезно для логов и измерения задержек.
- `hwtstamp`: аппаратная метка времени от NIC (если поддерживается и включено). Ставится «на железе» для высокой точности (PTP/latency).
- `tstamp_type`: источник метки времени (программная, аппаратная и т. п.).
- `napi_id`: идентификатор NAPI‑контекста приёма — номер «кассы»/очереди драйвера, через которую пакет пришёл, помогает анализировать распределение нагрузки.

Просто: `tstamp` — от ядра, `hwtstamp` — от железа, `tstamp_type` — какой источник, `napi_id` — какая очередь приёма.

## Хеш и ключи потока

- `hash`: хеш потока по ключевым полям (src/dst IP, порты, L4), который считают ядро или NIC. Используется для балансировки/очередей, позволяет быстро группировать пакеты одного соединения.
- `flow_keys`: указатель на `bpf_flow_keys` — удобная структура с основными полями потока (адреса, порты, протокол L4 и др.), которую можно заполнить хелпером и не парсить заголовки вручную.

Коротко: `hash` — «штрих‑код» потока, `flow_keys` — его «паспорт» одной структурой.

## GSO и оффлоады

- `gso_size`: размер сегмента при Generic Segmentation Offload — на какие кусочки NIC порежет крупный L4‑сегмент.
- `gso_segs`: количество сегментов после разбиения — сколько обычных кадров появится на проводе.

Нужно учитывать для правильного подсчёта реального трафика и нагрузки.

## Связь с сокетом

- `sk`: указатель на `bpf_sock` — связь пакета с конкретным сокетом/соединением, если ядро может её установить. Через `bpf_sock` доступны сведения о владельце (процесс/cgroup), адресах/портах, состоянии TCP, метках и лимитах. Может быть недоступен/NULL для пакетов без сокета (ARP, ранние этапы).

Полезно для решений per‑connection: квоты, метки, запреты/разрешения, точная статистика.

## Практические замечания

- Доступность и семантика некоторых полей зависят от точки подключения программы (XDP/TC/CGROUP/SK) и драйвера/NIC.
- Всегда проверяйте границы: любые чтения должны гарантированно находиться между `data` и `data_end`.
- Для констант и кодов протоколов используйте UAPI: `include/uapi/linux/if_ether.h`, `linux/in.h`, `linux/if_vlan.h`.
- Порты в сетевом порядке (big‑endian): учитывайте преобразования при сравнении.

Этот файл можно читать по разделам, последовательно осваивая каждую группу полей.
